## 数据库与模板系统

### 一、ORM:对象关系映射

​		![1568108298851](C:\Users\lwq\Desktop\tornado\2.数据库与模板系统\1568108298851.png)

#### 1、概述

ORM全称是：Object Relational Mapping(对象关系映射)。其主要作用是在编程中把面向对象的概念跟数据库中表的概念对应起来。

就好比：我定义一个类，那就对应着一张表，这个类的实例，就对应着表中的一条记录

面向对象编程把所有的实体看成对象(object)，关系型数据库则是采用实体之间的关系(relation)连接数据

很快有人提出，关系也可以用对象表达，这样就能使用面向对象编程，来操作关系型数据库。

**ORM的优点：**

- 数据模型都在一个地方定义，更容易更新和维护，也利于重用代码

- ORM 有现成的⼯具，很多功能都可以⾃动完成，⽐如数据预处理、事务等等。
- 它迫使你使⽤ MVC 架构，ORM 就是天然的 Model，最终使代码更清晰。
- 基于 ORM 的业务代码⽐较简单，代码量少，语义性好，容易理解。
- 你不必编写性能不佳的 SQL。

缺点：orm的sql语句性能可能会不是最佳的，性能比较普通，所以有时候要自己手写sql语句

Python下常⽤的 ORM 有: Django-ORM、SQLAlchemy、Peewee 等

#### 2、示例

我们这⾥使⽤ SQLAlchemy 来操作数据库，直接看代码:

```python
import datetime
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy import Column, String, Integer, Float, Date
from sqlalchemy.ext.declarative import declarative_base
# 建⽴连接与数据库的连接
engine = create_engine('mysql+pymysql://lwq:123123@localhost:3306/tornado')
Base = declarative_base(bind=engine) # 创建模型的基础类
Session = sessionmaker(bind=engine)
class User(Base):
    # 类本身对应数据库里的表结构
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(20), unique=True)
    birthday = Column(Date, default=datetime.date(1990, 1, 1))
    city = Column(String(10), default='上海')


Base.metadata.create_all()  # 创建表结构

# 定义的每一个对象对应数据库里的一行数据
bob = User(name='bob', birthday=datetime.date(1990, 3, 21), city='上海')
tom = User(name='tom', birthday=datetime.date(1995, 9, 12))
lucy = User(name='lucy', birthday=datetime.date(1998, 5, 14), city='北京')
jam = User(name='jam', birthday=datetime.date(1994, 3, 9), city='深圳')
alex = User(name='alex', birthday=datetime.date(1992, 3, 17), city='北京')
eva = User(name='eva', birthday=datetime.date(1987, 7, 28), city='深圳')
rob = User(name='rob', birthday=datetime.date(1974, 2, 5), city='上海')
ella = User(name='ella', birthday=datetime.date(1999, 5, 26), city='北京')
session = Session()
# 增加数据
obj=[bob,tom,lucy,jam,alex,eva,rob,ella]
session.add_all(obj) # 在 Session 中记录操作
session.commit() # 提交到数据库中执⾏
# 删除数据
session.delete(jam) # 记录删除操作
session.commit() # 提交到数据库中执⾏
# 修改数据
tom.city = '重庆' # 修改数据
session.commit() # 提交到数据库中执⾏
# 查询数据
u_query = session.query(User) # 先定义表的查询对象
# get直接获取主键(ID)为 5 的数据
user = u_query.get(5)
print(user.id, user.name)
# 使⽤ filter 进⾏范围查询，并对结果进⾏排序
users = u_query.filter(User.id>2).order_by('birthday')
for u in users:
 print(u.name, u.birthday, u.money)
# 使⽤ filter_by 按条件查询
user = u_query.filter_by(id=7).one()
print(user.id, user.name, user.birthday)
# 根据查询结果进⾏更新
users.update({'city': '魔都'+users.city}, synchronize_session=False)
sessiom.commit()
# 按数量取出数据: limit / offset
users = u_query.limit(3).offset(4) #越过4个，再取3
for u in users:
 print(u.id, u.name)
# 计数
num = u_query.filter(User.id>3).count()
print(num)
# 检查是否存在
exists = q.filter_by(name='lwq').exists()
result = session.query(exists).scalar()
print(result)
```

## 二、Tornado的模板系统

模板系统是为了更快速，更方便的生产大量的页面而设计的一套程序

借助模板系统，我们可以先写好页面大概的样子，然后预留好数据的位置，再然后将我们需要的数据，按照既定规则拼到模板中的指定位置，然后渲染出完整页面。

现代的模板系统已经相当成熟，甚至可以通过`if...else、for`等语句在模板中写出简单的逻辑控制

#### 1、模板与静态文件的路径配置

在定义app时，在Application中定义，可以是相对路径，也可以是绝对路径,此处是绝对路径

```python
def make_app():
    routes = [
        (r'/', MainHandler),
        (r'/block', BlockHandler),
        (r'/tttt', StaticTestHandler),
    ]
    base_dir = os.path.dirname(os.path.abspath(__file__))
    template_dir = os.path.join(base_dir, 'templates')
    static_dir = os.path.join(base_dir, 'static')
    print(base_dir)
    
    return tornado.web.Application(routes,
                      # 模板的存放路径
                     template_path=template_dir,
                   # 静态文件（图片视频等）的存放路径
                     static_path=static_dir)
```

#### 2、模板中的变量

在模板中，变量和表达式的使用`{% ... %}`包围，可以写入任何的python表达式或者变量

index.html:

```html
<html>
   <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>lwq</title>

        <style>
            h1, p {
                text-align: center;
                font-size: 2.5em;
            }
            .avatar {
                border-radius: 20px;
                box-shadow: 5px 5px 20px grey;
                width: 500px;
                margin: 0 auto;
                display: block;
            }
        </style>
    </head>
    <body>
        <h1>lwq</h1>
        <div><img class="avatar" src="https://inews.gtimg.com/newsapp_ls/0/10229330043_294195/0" /></div>
        {% if sex == '男' %}
        <div>你好 {{ name }}，欢迎回来先生！</div>
        {% elif sex == '女' %}
        <div>你好 {{ name }}，欢迎回来美女！</div>
        {% else %}
        <div>你好 {{ name }}，欢迎回来，神秘人！</div>
        {% end %}

        <hr />
        正文：
        <p>{{ data }}</p>


        <hr />

        您今天的菜谱请过目：
        <ol>
            {% for item in menu %}
            <li>{{ item }}</li>
            {% end %}
        </ol>
        <hr />

        <div>猜⼀猜，3 x 2 等于⼏？</div>
        <div>
            我就不告诉你等于 <strong>{{ 3 * 2 }} </strong>
        </div>
        <div>
            给你写个列表： <strong>{{ [i for i in range(10)] }}</strong>
        </div>
    </body>
</html>
```

#### 3、从python程序中传递参数

```python
class MainHandler(tornado.web.RequestHandler):
    def get(self):
        abc = self.get_argument('arg', '嘿嘿嘿嘿嘿')
        name = self.get_argument('name', 'Admin')
        sex = self.get_argument('sex', '保密')
        menu = ['红烧肉', '水果沙拉', '溜肥肠', '牛排', '大肠刺身']
        self.render('index.html', data=abc, name=name, sex=sex, menu=menu)
```

#### 4、模板中的`if...else`结构

模板中的控制语句使⽤ {% ... %} 包围，如下所示

```html
<p>
 根据您的条件我们进⾏了筛选
 {% if 条件 %}
 <div>第 1 条数据</div>
 <div>第 2 条数据</div>
 <div>。。。</div>
 {% else %}
 <div>抱歉我们没有找到合适的内容</div>
 {% end %}
</p>
```

#### 5、模板中的for循环

python程序中：

```python
class MainHandler(tornado.web.RequestHandler):
 def get(self):
 students = ["Lucy", "Tom", "Bob"]
 self.render("student.html", students=students)
```

student.html:

```html
<html>
 	<head>
		 <title>学⽣信息</title>
 	</head>
 	<body>
		 <ul>
 			{% for student in students %}
 			<li>{{ student }}</li>
 			{% end %}
 		</ul>
 	</body>
</html>
```

#### 6、静态文件

1、 先参照第 1 ⼩结添加静态⽂件的路径配置

2、⻚⾯中静态⽂件的路径需要以 '/static/' 开头, 后⾯跟⽂件路径。⽐如，⽬录结构如下：

```sql
├── main.py
├── statics
│   └── img
│       └── coder.jpg
├── templates
│   ├── article.html
│   ├── base.html
│   ├── index.html
│   └── static_test.html
```

#### 7、模板的继承

网站中，大多数页面都是同样的结构和风格，我们没必要在所有的页面中把相同的样式重复的写很多遍

Tornado为我们提供了模板的继承机制，只需要写好父模板，然后让其他模板继承一下即可

父模板文件名经常定义为'base.html'

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Lwq</title>
        <style>
            body{
                width:900px;
                margin:0 auto;
            }
            .content {
                float:left;
                width:700px
            }
            .sidebar{
                float:left;
                width:200px
            }
        </style>
    </head>

    <body>
<!--        导航区域-->
        <div class="navbar">
            <a href="#">要闻</a>
            <a href="#">娱乐</a>
            <a href="#">财经</a>
            <a href="#">体育</a>
            <a href="#">汽车</a>
        </div>

        <hr />
<!--        内容区域-->
        <div class="content">
<!--            声明以后要在此处拼一些东西进来-->
            {% block container %} 啥都没有 {% end %}

        </div>

<!--        边栏区域-->
        <div class="sidebar">
            <ul>
                <li><a href="#">数据模型都在⼀个地⽅定义，也利于重⽤代码。</a></li>
                <li><a href="#">ORM 有现成的⼯具，⽐如数据预处理、事务等等。</a></li>
                <li><a href="#">它迫使你使⽤ MVC  Model，最终使代码更清晰。</a></li>
                <li><a href="#">基于 ORM，语义性好，容易理解。</a></li>
                <li><a href="#">你不必编写性能不佳的 SQL。</a></li>
            </ul>
        </div>
    </body>
</html>
```

字模板：(article.html)

```html
<!--base的扩展内容-->
{% extends "base.html" %}

根据block的名字找到填充的位置，block可以写多个，但后面的名字不能重复
{% block container %}

<h1>{{ title }}</h1>

<p>
    {{ content }}
</p>

{% end %}
```

## 三、练习

利⽤ SQLAlchemy 重新创建昨天的表结构，实现下⾯接⼝

1. 开发接⼝，并根据⽤户传⼊的 id 显示对应的⽤户信息
2. 开发接⼝，并根据⽤户传⼊的数值修改⽤户数据
3. 整体数据在使⽤模版展现出来，边栏显示学⽣姓名，点击边栏链接可以显示相应学⽣信息
# 查找方法的使用

- match方法(只匹配字符串开头)
- search方法(扫描整个字符串，找到第一个匹配)
- findall方法(扫描整个字符串，找到所有的匹配)
- finditer方法(扫描整个字符串，找到所有的匹配，并返回一个可迭代对象)

## match方法的使用

re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。

```python
re.match(pattern,string,flags=0)
```

| 参数    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| pattern | 匹配的正则表达式                                             |
| string  | 要匹配的字符串。                                             |
| flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 |

我们可以使用group(num)函数来获取匹配表达式。

```python
import re
result1 = re.match(r'H','Hello')
result2 = re.match(r'e','Hello')
print(result1.group(0)) # 'H' 匹配到的元素
print(result1.span()) # (0,1) 匹配到的元素所在位置
print(result2)  # None
```

## search方法的使用

re.search 扫描整个字符串并返回第一个成功的匹配。

函数语法：

```python
re.search(pattern, string, flags=0)
```

### re.match与re.search的区别

re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。

## findall 方法的使用

在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。

**注意：** match 和 search 是匹配一次 findall 匹配所有。

语法格式：

```python
re.findall(pattern,string,flags=0)
```

注意事项:

findall方法匹配时，如果匹配规则里有分组，则只匹配分组数据。

```python
ret = re.findall(r'\w+@(qq|126|163)\.com','123@qq.com;aa@163.com;bb@126.com')
print(ret)  # ['qq', '163', '126']  只匹配到了分组里的内容
```

如果正则表达式里存在多个分组，则会把多个分组匹配成元组。

```python
ret = re.findall(r'\w+@(qq|126|163)(\.com)','123@qq.com;aa@163.com;bb@126.com')
print(ret) #[('qq', '.com'), ('163', '.com'), ('126', '.com')]
```

如果想要让findall匹配所有的内容，而不仅仅只是匹配正则表达式里的分组，可以使用 `?:`来将分组标记为非捕获分组。

```python
ret = re.findall(r'\w+@(?:qq|126|163)\.com','123@qq.com;aa@163.com;bb@126.com')
print(ret) # ['123@qq.com', 'aa@163.com', 'bb@126.com']
```

## finditer方法的使用

和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。

```python
ret = re.finditer(r'\d+','he23ll34')  # 得到的结果是一个可迭代对象
for x in ret: # 遍历 ret 取出里面的每一项匹配
    print(x.group(), x.span()) # 匹配对象里的group保存了匹配的结果
```

# re.Match类介绍

当我们调用`re.match`方法、`re.search`方法，或者对`re.finditer`方法的结果进行迭代时，拿到的数据类型都是`re.Match`对象。

| 属性和方法       | 说 明                                                        |
| ---------------- | ------------------------------------------------------------ |
| pos              | 搜索的开始位置                                               |
| endpos           | 搜索的结束位置                                               |
| string           | 搜索的字符串                                                 |
| re               | 当前使用的正则表达式的对象                                   |
| lastindex        | 最后匹配的组索引                                             |
| lastgroup        | 最后匹配的组名                                               |
| group(index=0)   | 某个分组的匹配结果。如果index等于0，便是匹配整个正则表达式   |
| groups()         | 所有分组的匹配结果，每个分组的结果组成一个列表返回           |
| groupdict()      | 返回组名作为key，每个分组的匹配结果座位value的字典           |
| start([group])   | 获取组的开始位置                                             |
| end([group])     | 获取组的结束位置                                             |
| span([group])    | 获取组的开始和结束位置                                       |
| expand(template) | 使用组的匹配结果来替换模板template中的内容，并把替换后的字符串返回 |

```python
ret = re.search(r'(abc)+', 'xxxabcabcabcdef')
print(ret.pos)  # 搜索开始的位置，默认是0
print(ret.endpos)  # 搜索结束的位置，默认是字符串的长度
print(ret.group(0)) # abcabcabc 匹配整个表达式
print(ret.group(1))  # abc 第一次匹配到的结果
print(ret.span()) # (3, 12) 开始和结束位置
print(ret.groups())  # 表示当正则表达式里有多个分组时，多个分组的匹配结果
```

# re.compile方法的使用

我们在使用正则表达式时，可以直接调用`re` 模块的 `match,search,findall`等方法，传入指定的正则表达式。同时，也可以调用re.compile方法，生成一个正则表达式对象，再调用这个正则表达式对象的相关方法实现匹配。

示例：

```python
re.match(r'h','hello')  # 可以使用re.match方法直接匹配
# 也可以调用re模块的compile方法，生成一个 Pattern 对象，再调用 Pattern 对象的 match方法
regex = re.compile(r'h')
regex.match('hello')
```


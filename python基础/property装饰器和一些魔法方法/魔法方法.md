### 魔方方法的总结

```python
class Person(object):
    def __new__(cls, *args, **kwargs):
        """
        申请内存空间
        :param args:
        :param kwargs:
        :return:
        """
        return object.__new__(cls)

    def __init__(self, name, age):
        """
        创建Person对象时，会自动调用的方法
        :param name:
        :param age:
        """
        self.name = name
        self.age = age

    def __str__(self):
        """
        当对象被转换成为字符串的时候，会自动调用这个方法
        :return:
        """
        return 'hehe'

    def __del__(self):
        """
        对象被删除时，自动调用的方法
        :return:
        """
        del self

    def __eq__(self, other):
        """
        当对象做 == 比较时调用的方法
        :param other:
        :return:
        """
        return self.name == other.name and self.age == other.age

    def __gt__(self, other):
        """
        当对象之间做大于运算时调用的方法。
        :param other:
        :return:
        """
        return self.age > other.age

    # 迭代器，需要返回一个迭代器
    # 如果一个类重写了这个方法，它就是一个可迭代对象
    # def __iter__(self):

    # 迭代对象时，自动调用的方法
    # def __next__(self):

    # def __ge__(self, other):
    # def __lt__(self, other):
    # def __le__(self, other):
    # def __ne__(self, other):

    # 位运算相关
    # def __and__(self, other):
    # def __or__(self, other):
    # def __xor__(self, other):

    # 算数运算相关
    # def __add__(self, other):
    # def __sub__(self, other):
    # def __mul__(self, other):
    # def __truediv__(self, other):
    # def __floordiv__(self, other):

    def __call__(self, *args, **kwargs):
        print('我被调用了')


p1 = Person('张三', 18)
p2 = Person('李四', 21)
p3 = Person('王五', 17)

persons = [p1, p2, p3]

# 如果重写了对象的 __gt__ 或者 __lt__ 方法，对象可以直接根据这两个方法的规则进行排序
# persons.sort()
# sorted(persons)

# 如果没有重写__gt__或者__lt__方法，对对象排序时，需要传入key
# persons = sorted(persons, key=lambda ele: ele.age)


for p in persons:
    print(p.name)

# 把对象p当做一个函数来调用。默认情况下，是不能够被当做函数直接调用的
# 变量()  ==> 本质是调用这个对象的 __call__方法
p()
```

### __ slots__方法

用来规定该对象到底可以添加那些属性，还可以继承给子类

```python
class Person(object):
    # 属性用来规定对象到底可以有哪些属性
    __slots__ = ('name', 'age', 'gender')

    def __init__(self, name, age):
        self.name = name
        self.age = age


p = Person('张三', 18)

# python支持动态属性
p.gender = 'male'
print(p.gender)

# Person.__slots__ = ('hehe', 'hi')
p.gender = 'female'
print(p.gender)


class Student(Person):
    __slots__ = ('score', 'grade')

    def __init__(self, score, name, age):
        super().__init__(name, age)
        self.score = score


s = Student(90)
s.name = '李四'
s.age = '20'
s.grade = '中二班'
s.gender = 'female'
print(s.name, s.age, s.score, s.grade)

```

### 另外一点

```python
class Person(object):
    """
    人类，具有姓名，年龄等属性
    """

    def __init__(self, name, age):
        self.name = name
        self.age = age
```

```python
p = Person('zhangsan', 18)

# __class__  类名
print(p.__class__)  # <class '__main__.Person'>

# __module__ 模块名
print(p.__module__)  # __main__

print('姓名:{},年龄{}'.format(p.name, p.age))
print('姓名:{name},年龄{age}'.format(name=p.name, age=p.age))

info = {'name': 'henry', 'age': 29}
print('姓名:{name},年龄{age}'.format(**info))

# __dict__ 将一个对象转换成为一个字典
dict_p = p.__dict__
print(dict_p)  # {'name': 'zhangsan', 'age': 18}
print('姓名:{name},年龄{age}'.format(**dict_p))

# 拿到一个对象的文档说明
# print(p.__doc__)
# help(p)

# help(random.Random)
# print(random.Random.__doc__)
```

### 把对象当做字典来使用

```python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __getitem__(self, item):
        # print('__getitem__方法被调用了{}'.format(item))
        return self.__dict__[item]

    def __setitem__(self, key, value):
        self.__dict__[key] = value

    def __delitem__(self, key):
        del self.__dict__[key]


p = Person('zhangsan', 18)

# __dict__ 可以将对象转换成为一个字典，可以通过操作字典来获取和修改对象的属性
# print(p.__dict__)
# print(p.__dict__['name'])
# p.__dict__['name'] = 'wangwu'
# print(p.name)

# 对象名[属性名] 把对象当做字典来使用，其实会调用对象的 __getitem__方法
print(p['name'])
print(p['age'])
p['name'] = 'lisi'
print(p['name'])
del p['name']

# print(p.name)
```

### 对象的切片

```python
class Person(object):
    __hobbies = ['swimming','walking','hiking','playing']
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def __str__(self):
        return self.__hobbies

    def __delslice__(self,i,j):
        del self.__hobbies[i:j]
    def __setslice__(self, i, j, sequence):
        self.__hobbies[i:j] = sequence

p = Person('张三',123)
print(Person.__str__(p))

p.__setslice__(1, 2, ['running', 'singing'])
print(Person.__str__(p))
p.__delslice__(1,2)
print(Person.__str__(p))

```


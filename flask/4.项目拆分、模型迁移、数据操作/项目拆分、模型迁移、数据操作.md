### 学习目标

- 项目拆分
- flask-migrate
- DML
  - 增
  - 删
  - 改
- DQL
  - 查
    - 获取单个数据
    - 获取数据集
    - 数据筛选
    - 分页
    - 逻辑运算
- 数据定义
- 模型关系
  - 一对多
  - 一对一
  - 多对多

## 学习内容

#### 1、项目拆分

```
1、开发环境分为四套
		开发环境  假数据		develop
		测试环境  数据量大一些  压力测试    假数据    test
		演示环境  接近线上环境  实施工程师做的给客户看是否符合需求show
		线上环境  真实数据    product
2、拆分项目
	规划项目结构
		manager.py
			app的创建
			Manager (flask-script管理对象)
		App
			__init__
				创建Flask对象
				加载settings文件
				调用init_ext方法
				调用init_blue方法
			settings
				App运行的开发环境配置，四种数据库的开发环境
			ext(扩展的，额外的)
				flask-Blueprint
				用来初始化第三方的各种插件
				flask_script
				Sqlalchemy对象的初始化 数据库flask_sqlalchemy
				Session初始化  flask_session
				flask_migrate
			Views
				蓝图
				创建
				注册在app上在manager
				app.register_blueprint(blueprint=blue)
			models
				定义模型
```

#### 2、flask-migrate

迁移模型对象

Flask-Migrate是一个为Flask应用处理SQLAlchemy数据库迁移的扩展，使得可以通过Flask的命令行接口或者Flask-Scripts对数据库进行操作。

```
步骤：
	1、安装
		pip install flask-migrate
	2、初始化
		1、创建migrate对象
		  需要将app和db初始化  在ext中
		  	migrate = Migrate()
		  	migrate.init_app(app=app,db=db)
		2、懒加载初始化
			结合flask-script使用
			在manager上添加command(MigrateCommand)
			manager.add_command('db',MigrateCommand)
			此处的db要与下面运行命令使用的db相同
		3、python manager.py db xxx
			(1)init			  第一次使用
			(2)migrate		  生成一个迁移文件(migrations)
							  不能生成有两种情况
							  	1、模型定义完成从未调用
							  	2、数据库在migrate之前就已经有了模型记录，需要清空数据库，重新init
			(3) upgrade 	  升级  把模型实例成表即创建表表
			(4) downgrade     降级  把表返回成模型即其清除表
		扩展：
		创建用户名文件
		python manager.py db migrate --message '创建了表...'
		给生成的文件加了个说明，可以看出进行了什么操作
```

#### 3、DML

```
1、增
	创建对象
	(1)添加一个对象
		db.session.add()
		eg:
			@blue.route('/addStudent/')
			def addStudent():
    			s = Student()
    			s.name = 'zs'
    			s.age = 18
    			db.session.add(s)
    			db.session.commit()
    			return '添加成功'
    (2)添加多个对象
    	db.session.add_all([])
    	eg:
    		@blue.route('/addStudentList/')
			def addStudentList():
    			student_list = []
    			for i in range(5):
        			s = Student()
        			s.name = '小明%d' % i
        			s.age = i
        			student_list.append(s)
    			db.session.add_all(student_list)
    			db.session.commit()
    			return '添加成功'
```

```
2、删除
	需要配合查询进行删除
	s = Student.query.first()
	db.session.delete(s)
```

```
3、修改
	s.name='ss'
	db.session.add(s)
	基于查询
```

#### 查

```
1、获取单个数据
	(1)get
		主键值
		获取不到不会报错-->指的是必须是单纯的查询，不能使用，如果使用了会报没有属性值的错误
		s = Student.query.get(10)
	(2)first
		person = Person.query.first
```

```
2、获取结果集
	# all方法返回的是一个列表
    student_list = Student.query.all()
    # 扩展
    #   flask =====>BaseQuery
    #   tornado =====>Query
    #   django =====> QuerySet
    
    # filter_by 返回值类型是BaseQuery
    
    # filter和fileter_by对主键字段的操作
    s1 = Student.query.filter_by(id=3)
    student_list = Student.query.filter(id==3)

    # filter和fileter_by对非主键字段的操作
    student_list = Student.query.filter_by(age = 3)
    student_list = Student.query.filter(Student.age == 3)
    print(type(student_list))

    # 条件查询
  student_list=Student.query.filter(Student.age.__gt__(2))
  student_list=Student.query.filter(Student.age.__lt__(2))
  student_list = Student.query.filter(Student.age > 2)
  student_list=
  Student.query.filter(Student.name.startswith('小'))
  student_list=
  Student.query.filter(Student.name.endswith('1'))
  student_list=
  Student.query.filter(Student.name.contains('小'))
  student_list = Student.query.filter(Student.age.in_([1, 2]))
```

```
3、数据筛选
	# 排序
升序 student_list = Student.query.order_by('age')
降序 student_list = Student.query.order_by(db.desc('age'))

    # limit 取出前几条数据
    student_list = Student.query.limit(3)

    # offset 去除前几个数据
    # student_list = Student.query.offset(3)

    # 分页
    # 现在有五条数据  假如一页有两条，那么一共有3页
    # 要第二页的数据（limit, offset）
    # 总结： limit和offset无论谁先写,都是offset先执行
    # student_list = Student.query.limit(2).offset(2)

    # limit offset order_by
    # order_by 无论是语法和执行顺序都是先执行排序
    student_list = Student.query.order_by(db.desc('age')).limit(2).offset(2)	
```

```
4.pagination
	（1）简介：分页器
              需要想要的页码
              每一页显示多少数据
	（2）原生：
			    # 第1页  2  0
    			# 第2页  2  2
   				# 第3页  2  4
                student_list = Student.query.limit(page_per).offset((page-1)*page_per)

	（3）封装：
          	 参数（page，page_per,False(是否抛异常）
         	 persons = Person.query.paginate(page_num, page_per, False).items
        paginate的返回值是pagination，不可以进行遍历，想要遍历需要在后面跟上items
```

```
5、逻辑运算
	导包时除了not
	1、与
			and_   	filter(and_(条件)
			song = Song.query.filter(and_(Song.id==1,Song.name=='爱情买卖'))[0]
	
	2、或
		or_  filter(or_(条件))
song = Song.query.filter(or_(Song.id==1,song.name=='说好不哭'))[1]
	3、非
		not_    filter(not_(条件))
songs = Song.query.filter(not_(Song.id==1))
for song in songs:
	print song.id
	4、in   in_([...])
songs = Song.query.filter(in_([1,2,3,4]))
```

### 4、数据定义

```
1、字段类型
		Integer
		String
		Date
		Boolean
2、约束
		primary_key   (主键)
		autoincrement (主键自增长)
		unique		  (唯一值)
		default		  (默认值)
		index		  (索引)
		not null	  (非空)
		ForeignKey    (外键) 用来约束级联数据
			db.Column(db.Integer,db.ForeignKey(表名.主键))
			一对一和一对多时，表名.主键带'',多对多时，不带''.
			使用relationship实现级联数据获取，声明级联数据
				backref='表名'   lazy=True
```

### 5、模型关系

##### 1、一对多

​	一个父亲有多个孩子

```
1、模型定义
Class Parent(db.Model):
	id = db.Column(db.Intrger, primary_key=True, autoincrement=True)
	name = db.Column(db.String(32),unique=True)

	children = db.relationship('Child',backref='parent',lazy=True)

class Children(db.Model):
	id = db.Column(db.Integer, primary_key=True, autoincrement = True)
	name = db.Column(db.String(32),unique=True)
	
	parent_id = db.Column(db.Integer,db.ForeignKey('parent.id'))
```

```
2、参数介绍：
	1、relationship   是个函数
		sqlalchemy对关系之间提供的一种更便捷的调用方式，关联不同的表；
	2、第一个参数是字表的表名，带引号
	3、backref参数
		对关系提供反向引用的声明，在Parent类上声明新属性的简单方法，，之后可以在Child.person 来获取这个对象的person
	4、lazy参数
		1、'select' (默认值)
		SQLAlchemy会在使用一个标准 select语句时一次性加载数据：
		适合数据量比较少的事就
		2、'joined'
		让SQLAlchemy当父级使用JOIN语句时，在相同的查询中加载关系
		3、'subquery'
		类似'joined',但是SQLAlchemy会使用子查询
		4、'dynamic'
		SQLAlchemy 会返回一个查询对象，，使用了这个，只有在使用对象的属性或者方法时才发送sql语句，一般情况下是查询的时候就发送SQL语句，大批量数据查询处理时推荐使用
	5、ForeignKey参数
                    代表一种关联字段，将两张表进行关联的方式，表示一个person的外键，设定上必须要能在父表中找到对应的id值
```

```
3、模型的应用
	添加
		@blue.route('/addParent/')
		def addParent():
    		parent = Parent()
    		parent.name = '张三'

    		child = Child()
    		child.name = '张四'

    		child1 = Child()
    		child1.name = '王五'

    		child_list = [child, child1]
    		parent.children = child_list

    		db.session.add(parent)
    		db.session.commit()
    		return '添加成功'
    	查
    主查从--> Parent -->Child
    	@blue.route('/getChild/')
		def getChild():
    		childs = Child.query.filter(Parent.id == 1)
    		for child in childs:
        		print(child.name)
    	return '查询成功'
    从查主
    	@blue.route('/getParent/')
		def getParent():
    		parents = Parent.query.filter(Child.id > 1)
    		for parent in parents:
        		print(parent.name)
    		return '查询成功'
	
```

##### 2、一对一

```
一对一需要设置relationship中的uselist=list,其他数据库操作一样
```

##### 3、多对多

```
（1）模型定义
          class User(db.Model):
              id = db.Column(db.Integer,primary_key=True,autoincrement=True)
              name = db.Column(db.String(32))
              age = db.Column(db.Integer,default=18)

          class Movie(db.Model):
              id = db.Column(db.Integer,primary_key=True,autoincrement=True)
              name = db.Column(db.String(32))

          class Collection(db.Model):
              id = db.Column(db.Integer,primary_key=True,autoincrement=True)
              u_id = db.Column(db.Integer,db.ForeignKey(User.id))
              m_id = db.Column(db.Integer,db.ForeignKey(Movie.id))
              num = db.Column(db.Integer,default=1)
```

```
# 多对多
# 需求：第一次和会插入到数据库，第二次会在原来的基础上 数量加1
@blue.route('/addCollection/')
def addCollection():
    u_id = request.args.get('u_id')
    m_id = request.args.get('m_id')
    collections = Collection.query.filter(Collection.u_id == u_id).filter(Collection.m_id == m_id)

    # collection.count() 获取basequery的元素长度
    if collections.count() > 0:
        collection = collections[0]
        # +=1 效率没这个快
        collection.num = collection.num + 1
        db.session.add(collection)
        db.session.commit()
    else:
        collection = Collection()
        collection.u_id = u_id
        collection.m_id = m_id
    db.session.add(collection)
    db.session.commit()
    return '添加成功'
```


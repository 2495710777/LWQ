## 一、权限管理

#### MySQL的权限分为两个阶段：

1、第一阶段为连接验证，主要限制用户连接mysql-server 时使用的ip及密码

2、第二阶段为操作检查，主要检查用户执行的指令是否被允许，一般非管理员账号不被允许执行drop、delete等危险操作

### 权限控制安全准则

1、只授予能满足需要的最小权限值，防止用户执行危险操作

2、限制用户的登陆主机，防止不速之客登录数据库

3、禁止或删除没有密码的用户

4、禁止用户使用弱密码

5、定时清理无效的用户、回收权限或者删除用户。

### 常见操作

1、创建账户、权限赋予

- 8.0之前版本：

  ```mysql
  grant all privileges on *.* to '用户名' @ '主机' idendified by "密码" with grant option;
  flush privileges;刷新使权限生效
  ```

  - all privileges:授予全部权限，也可以指定select、insert等
  - `*.*`允许操作的数据库和表，`.`代表所有权限
  - with grant option;带有该子句，说明允许用户将自己拥有的权限授予别人

- 8.0之后

  ```mysql
  create user `用户名` @ `主机` identified by '密码'; -- 创建账户
  grant all on *.* to `用户名` @ `主机` with grant option; -- 授权
  ```

2、修改密码

```mysql
alter user 'root' @ 'localhost' identified with mysql_native_password by '你的密码'
```

3、查看权限

```mysql
show grants; -- 查看当前用户的权限
show grant for 'abc' @ 'localhost'; -- 查看用户abc的权限
```

4、回收权限

```mysql
revoke delete on *.* from 'abc' @ 'localhost';
```

5、删除用户

```mysql
use mysql
select host,user from user;
drop user 用户名@ '%';
```

## 二、视图

- 试图是数据的特定子集，是从其他表中提取出数据而形成的虚拟表，或者说临时表。
- 创建视图依赖一个查询
- 视图是永远不会自己消除的，除非手动删除它
- 视图有时会提高效率，临时表不会对性能有帮助，是资源的消耗者
- 视图一般随该数据库存放在一起，临时表永远都是在tempdb中
- 视图适合于夺标连接浏览时使用；不适合用来增删改，这样可以提高效率
- 一般视图表的名称以`v_` 为前缀，用来于正常表进行区分
- 对原表的修改会影响到视图中的数据

#### 创建视图

语法：create view 视图名 as 查询语句

如：

```mysql
create view v_exam as ( 
select l.id,l.name,l.city,r.math,r.english 
from student l left join score r 
on l.id=r.id);

select * from v_exam;

drop view v_exam
```

## 三、存储引擎

存储引擎就是如何存储数据、如何为数据建立索引和如何更新、查询数据等技术的实现方法。

mysql默认支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以通过选择使用不同的存储引擎提高操作的效率，提供灵活的存储。

### 查看当前的存储引擎

```mysql
show variables like 'storage_engine';
show engines;
```

### MySQL常用的存储引擎


| 功能         | MYISAM | Memory | InnoDB | Archive |
| ------------ | ------ | ------ | ------ | ------- |
| 存储限制     | 256T   | RAM    | 64T    | None    |
| 支持事务     | no     | no     | Yes    | no      |
| 支持全文索引 | yes    | no     | no     | no      |
| 支持数索引   | yes    | yes    | yes    | no      |
| 支持哈希索引 | no     | yes    | yes    | no      |
| 支持数据缓存 | no     | N/A    | yes    | no      |
| 支持外键     | no     | no     | yes    | no      |

### 表的引擎

innoDB和Myisam

CURD 操作：增删改查

C  create 创建  insert 插入

U  update 更新修改

R   read  select 查询

D  delete  删除  

less /etc/mysql/my.cnf

创建的数据库默认的存储路径

root 里的 /var/lib/mysql

innodb 在写的操作上非常有优势（事务）CUD全是写的操作

myisam 在读的操作上非常的有优势（健全的索引）R操作

### 引擎的存储方式

myisam 将一张表存储为三个文件

demo.frm --> 存储表的结构

demo.MYD --> 存储的是数据

demo.MYI --> 存储的是表的索引

**myisam 的文件可以任意的移动**

innodb 将一张表存储为两个文件

demo.frm -->存储表的结构和表的索引

demo.ibd -->存储的是表的数据

ibd存储是有限的，存储不足自动创建ibd1,ibd2

**innodb的文件创建在哪儿就只能在哪儿，不能任意的移动**

1、innodb

​	事务型数据库的首选引擎，还支持事务安全表（ACID）,支持**行锁定和外键**，innodb是MySQL默认的引擎

​	innodb主要的特性有：

​		1.innoDB给MySQL提供了具有提交，回滚，崩溃恢复能力的事务安全存储引擎

​		2.innoDB是为处理巨大数据量的最大性能设计，它的**CPU效率**比其他基于磁盘的关系型数据库引擎高

​		3.innoDB存储引擎自带缓冲池，可以将数据和索引缓存在内存中。

​		4.innoDB支持外键完整性约束

​		5.innoDB被用在众多需要高性能的大型数据库站点上

​		6.innodb支持行级锁，myisam只能锁住表的全部数据

2、Myisam

​	myisam基于ISAM存储引擎，并对其进行扩展，它是web、数据仓储和其他应用环境下最常使用的存储引擎之一。Myisam拥有**较高的插入，查询速度**，但不支持事务

主要特性有：

​		1.大文件支持更好

​		2.当删除、更新、插入混用时，产生更少碎片

​		3.每个myisam表最大索引数是64，这个可以通过重新编译来改变，每个索引最大的列数是16

​		4.最大的键长度是1000字节

​		5.BLOB和TEXT列可以被索引

​		6.NULL被允许在索引的列中，这个值占每个键的0~1个字节

​		7.所有数字键值以高字节优先被存储以允许一个更高的索引压缩

​		8.myisam类型表的AUTO_INCREMENT 列更新比innodb的更快

​		9.可以把数据文件和索引文件放在不同目录

​		10.每个字符列可以有不同的字符集

​		11.有varchar的表可以固定或动态记录长度

​		12.varchar 和char 列可以多达64kb

​		13.只支持表锁，一次锁一整个表

3. MEMORY
memory存储引擎将表中的数据存储到内存中，为查询和引⽤其他表数据提供快速访问。更加快速（临时表，）

### 存储引擎的选择

一般来说，对插入和并发性能要求较高的，或者需要外键及事务支持的选择innodb,

插入较少，查询较多的场景，优先考虑myisam

### 创建引擎

一般在建表时添加

```mysql
create table abc(
	name char(10)
)engine=myisam charset=utf8
默认是innodb
```

## 四、索引

索引就是为特定的mysql字段进行一些特定的算法排序，比如二叉树的算法和哈希算法，哈希算法是通过建立特征值，然后根据特征值来快速查找

mysql索引的建立对于mysql的高效运行是很重要的，大大提高mysql的检索速度

![1567684315312](C:\Users\lwq\Desktop\Mysql笔记\数据库高级特性\1567684315312.png)

Figure 13.23: A B-tree  用的最多，并且是mysql默认的索引数据结构btree

通过 BTREE 算法建⽴索引的字段，⽐如扫描 20 ⾏就能得到未使⽤ BTREE 前扫描了 2^20 ⾏的结果

![1567684431366](C:\Users\lwq\Desktop\Mysql笔记\数据库高级特性\1567684431366.png)

哈希索引⽐较特殊，时间复杂度为 O(1), 但只适合等值⽐较⽅式的查询，不适合范围或⼤⼩⽐较进⾏查询

索引的优点：

​	一个字就是快，使用索引能大大提升查询速度

缺点：

​	额外的使用一些存储的空间

​	索引会让插入的速度变慢，因为插入一个值，后面的索引都要改变

### 索引的创建原则

- 适合用于频繁查找的列
- 适合经常用于条件判断的列
- 适合经常用于排序的列
- 不适合数据较少的列
- 不适合很少查询的列
- 列离散度越大

### 创建索引

1、建表时添加索引

```mysql
create table 表名(
	id int auto_increment,
    username varchar(20) not null
    index 索引名(字段名(长度))
);

create table t2( 
tno int primary key, 
tname char(20), 
tlocation char(20), 
unique idx_t_name (tname(10)));
```

2、后期添加索引

```mysql
create index 索引名 on 表名(字段名(长度));
长度不需要全部的，具有分辨性就行
```

### 删除索引

```mysql
drop index 索引名 on 表名;
```

### 唯一索引

它与前⾯的普通索引类似，不同的就是：索引列的值必须唯⼀，但允许有空值。如果是组合索引，则列值的组合必须唯⼀。

```mysql
create unique index 索引名 on 表名(字段(长度));

create table 表名 (
	id int not null,
    username varchar(16) not null,
    unique 索引名 (字段名(长度))
)
此处unique后面不加index也可以
```

### 查看索引

```mysql
show index from 表名;
```

## 五、关系与外键

关系型数据库的关系：

- 一对一
  - 在A表中有一条数据，在B中有且只有一条记录相匹配
  - 比如：学生表和成绩表
- 一对多
  - 在A表中有一条记录，在B表中有多条记录相对应
  - 比如：用户和发表的博客
  - 反过来就是多对一
- 多对多
  - A表中的一条记录有多条B表中的数据对应，同样B表中一条数据在A表中也有多条与之对应
  - 一个用户可以收藏多个博客，一个博客可以被多个用户收藏

### 外键

外键是一种数据的完整性约束，他是保证数据的一致性，不能给系统性能带来任何好处，并且会导致性能下降，公司里面明令禁止使用外键，，不能对系统性能带来任何好处

建⽴外键时，都会在外键列上建⽴对应的索引。外键的存在会在每⼀次数据插⼊、修改时进⾏约束检
查，如果不满⾜外键约束，则禁⽌数据的插⼊或修改，这必然带来⼀个问题，就是在数据量特别⼤的情况下，每⼀次约束检查必然导致性能的下降

出于性能的考虑，如果我们的系统对性能要求较⾼，那么可以考虑在⽣产环境中不使⽤外键

添加外键：`alter table 从表 add [constraint] [外键名称] foreign key (从表外键字段名) references 主表 (主表的主键);`

删除索引：`alter table 从表 drop foreign key 外键名称`

myisam也可以添加外键，不过不会有任何反应，不会报错

1. 构造数据

   ```mysql
   -- ⽤户表
   create table `user` (
   `id` int unsigned primary key auto_increment,
   `name` char(32) not null unique
   ) charset=utf8;
   -- 商品表
   create table `product` (
   `id` int unsigned primary key auto_increment,
   `name` char(32) not null unique,
   `price` float
   ) charset=utf8;
   -- ⽤户信息表: ⼀对⼀
   create table `userinfo` (
   `id` int unsigned primary key auto_increment,
   `phone` int unsigned unique,
   `age` int unsigned,
   `location` varchar(128)
   ) charset=utf8;
   -- ⽤户组表: ⼀对多
   create table `group` (
   `id` int unsigned primary key auto_increment,
   `name` char(32) not null unique
   ) charset=utf8;
   -- 订单表: 多对多
   create table `order` (
   `id` int unsigned primary key auto_increment,
   `uid` int unsigned,
   `pid` int unsigned
   ) charset=utf8;
   ```

   2、添加外键

   ```mysql
   -- 为 user 和 userinfo 建⽴关联的外键
   alter table userinfo add constraint fk_user_id foreign key(id) references
   user(id);
   -- 建⽴⽤户与组的外键约束
   alter table `user` add `gid` int unsigned;
   alter table `user` add constraint `fk_group_id` foreign key(`gid`)
   references `group`(`id`);
   -- 建⽴⽤户、商品、订单的外键约束
   alter table `order` add constraint `fk_user_id` foreign key(`uid`)
   references `user`(`id`);
   alter table `order` add constraint `fk_prod_id` foreign key(`pid`)
   references `product`(`id`);
   ```

   3、尝试插⼊数据后在删除，分别先对主表和⼦表进⾏⼀次删除






























































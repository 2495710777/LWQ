#### 并发和并行

- 并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）
- 并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的。

python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用。

所以在创建线程的时候需要导入threading

一个进程中可以开多个线程，为什么要有进程，而不做成线程呢？因为一个程序中，线程共享一套数据，如果都做成进程，每个进程独占一块内存，那这套数据就要复制好几份给每个程序，不合理，所以有了线程。

线程又叫轻量级进程，是一个基本的cpu执行单元，也是程序执行过程中的最小单元。一个进程最少也会有一个主线程，在主线程中通过threading模块，在开子线程

**进程线程的关系**

（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程

（2）资源分配给进程，进程是程序的主体，同一进程的所有线程共享该进程的所有资源

（3）cpu分配给线程，即真正在cpu上运行的是线程

（4）线程是最小的执行单元，进程是最小的资源管理单元

协程可以开很多很多，没有上限，切换之间的消耗可以忽略不计

**协程的优缺点：**

优点：

　　上下文切换消耗小

　　方便切换控制流，简化编程模型

　　高并发，高扩展性，低成本

缺点：

　　无法利用多核

　　进行阻塞操作时会阻塞掉整个程序

### 线程

```python
import threading
import time


def test(msg):
    time.sleep(2)
    print(msg)
    print(threading.current_thread().name)


# name子线程的名字 args 传函数的参数
t1 = threading.Thread(target=test, args=('hello',), name='我的线程')
t2 = threading.Thread(target=test, args=('hello',), name='我的线程')
# 在等待的4秒里打印hehe,在打印hello world
t1.start()

t1.join(5)
t2.start()
print('hehe')
```



线程本身具有的资源（程序计数器、一组寄存器和栈）

t.start() : 激活线程，

t.getName() : 获取线程的名称

t.setName() ： 设置线程的名称 

t.name : 获取或设置线程的名称

t.is_alive() ： 判断线程是否为激活状态

t.isAlive() ：判断线程是否为激活状态

t.setDaemon() 设置为后台线程或前台线程（默认：False前台线程）;通过一个布尔值设置线程是否为守护线程，必须在执行start()方法之后才可以使用。如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止；如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止

t.isDaemon() ： 判断是否为守护线程

t.ident ：获取线程的标识符。线程标识符是一个非零整数，只有在调用了start()方法之后该属性才有效，否则它只返回None。

t.join() ：逐个执行每个线程，执行完毕后继续往下执行，该方法使得多线程变得无意义

t.run() ：线程被cpu调度后自动执行线程对象的run方法

### 线程的变量使用

- 在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据
- 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）

```python
from threading import Thread

def work1(nums):
    nums.append(44)
    print("----in work1---",nums)

def work2(nums):
    print("----in work2---",nums)

g_nums = [11,22,33]

t1 = Thread(target=work1, args=(g_nums,))
t1.start()

t2 = Thread(target=work2, args=(g_nums,))
t2.start()
```

当多线程之间的数据混淆了之后，会产生错误，这个时候就需要一个线程锁来控制一下线程的操作,当一个线程在执行线程锁内的操作时，另外一个线程进不来，数据就不会混淆

### threading.RLock和threading.Lock 的区别

RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。 如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐。

```
import threading
lock = threading.Lock()    #Lock对象
lock.acquire()
lock.acquire()  #产生了死琐。
lock.release()
lock.release()　

import threading
rLock = threading.RLock()  #RLock对象
rLock.acquire()
rLock.acquire()    #在同一线程内，程序不会堵塞。
rLock.release()
rLock.release()
```

```python
import threading

num = 0


def test():
    global num
    with lock:
       	lock.acquire()
        for i in range(100000000):
            num += 1
            num -= 1
       	lock.release()
    print(num)


# 用同一把锁把程序锁起来，被锁住的程序运行时其他进程进不来
# with 关键字只能用在具有enter方法和exit方法的地方
lock = threading.Lock()
t1 = threading.Thread(target=test)
t2 = threading.Thread(target=test)

t1.start()
t2.start()
```

#### threadLocal

可以在每一个线程中都定义一个专属的变量，相当于局部变量，如果想要与别的程序用一个，需要调用连接起来

```python
import threading

# threadLocal 看起来像是一个全局变量，但是其实每个线程在执行的时候，都会备份一份
local_data = threading.local()


def test():
    local_data.num = 2
    print(local_data.num)
    print(threading.current_thread().name)
    # 同一个线程的不同参数可以直接传参
    foo()


def foo():
    local_data.num += 5
    print(local_data.num)
    print(threading.current_thread().name)


def fn():
    local_data.num = 1
    print(local_data.num)


t1 = threading.Thread(target=test, name='线程t1')
t2 = threading.Thread(target=fn)
t3 = threading.Thread(target=foo, name='线程t3')

t1.start()

# t1.join()
t2.start()
```

### 线程间的通信

运用queue队列的特点（先进先出进行连接）

```python
import threading
import time
from queue import Queue

# 生产放进queue中
def produce():
    for i in range(10):
        print('生产了商品{}-->'.format(threading.current_thread().name), i)
        queue.put('商品-->{}'.format(threading.current_thread().name), i)
        time.sleep(0.5)
# get_nowait  get(timeout=1)
# 消费从queue中取出
def consume():
    for x in range(10):
        print('消费者{}正在等待'.format(threading.current_thread().name))
        x = queue.get()
        print('{}取到了{}'.format(threading.current_thread().name, x))
        time.sleep(0.5)
queue = Queue()
# 多线程之间的通讯
# 两个线程生产，三个线程取，不够取，等待
t1 = threading.Thread(target=produce)
t2 = threading.Thread(target=produce)


t3 = threading.Thread(target=consume, name='t3')
t4 = threading.Thread(target=consume, name='t4')
t5 = threading.Thread(target=consume, name='t5')

t1.start()
t2.start()
t3.start()
t4.start()
t5.start()
```

